const U=(()=>{const o="AES-CBC",s=t=>new TextEncoder().encode(t),d=t=>new TextDecoder().decode(t),i=async t=>crypto.subtle.importKey("raw",s(t),{name:o},!1,["encrypt","decrypt"]),p=async t=>crypto.subtle.importKey("raw",s(t),{name:"HMAC",hash:"SHA-256"},!1,["sign","verify"]);return{encrypt:async(t,n)=>{const r=await i(n),e=crypto.getRandomValues(new Uint8Array(16)),a=await crypto.subtle.encrypt({name:o,iv:e},r,s(t)),c=await p(n),y=await crypto.subtle.sign("HMAC",c,new Uint8Array([...e,...new Uint8Array(a)])),w=new Uint8Array([...e,...new Uint8Array(a),...new Uint8Array(y)]);return btoa(String.fromCharCode(...w))},decrypt:async(t,n)=>{const r=new Uint8Array(atob(t).split("").map(u=>u.charCodeAt(0))),e=r.slice(0,16),a=r.slice(-32),c=r.slice(16,-32),y=await p(n);if(!await crypto.subtle.verify("HMAC",y,a,new Uint8Array([...e,...c])))throw new Error("数据校验失败，可能已被篡改");const l=await i(n),A=await crypto.subtle.decrypt({name:o,iv:e},l,c);return d(new Uint8Array(A))}}})();export{U as C};
